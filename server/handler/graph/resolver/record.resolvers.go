package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"kakeibo-web-server/domain"
	"kakeibo-web-server/handler/graph"
	"kakeibo-web-server/lib/ctxdef"
	"kakeibo-web-server/lib/typeutil"

	"golang.org/x/xerrors"
)

// Asset is the resolver for the asset field.
func (r *assetChangeResolver) Asset(ctx context.Context, obj *domain.AssetChange) (*domain.Asset, error) {
	thunk := r.Loaders.AssetLoader.Load(ctx, obj.AssetID)

	asset, err := thunk()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	return asset, nil
}

// CreateIncomeRecord is the resolver for the createIncomeRecord field.
func (r *mutationResolver) CreateIncomeRecord(ctx context.Context, input domain.CreateIncomeRecordInput) (*domain.Record, error) {
	userID, err := ctxdef.UserID(ctx)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	record, _, err := r.usecase.CreateIncomeRecord(ctx, userID, input.Title, input.Description, input.At, domain.AssetID(input.AssetID), input.Amount)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	return record, nil
}

// CreateExpenseRecord is the resolver for the createExpenseRecord field.
func (r *mutationResolver) CreateExpenseRecord(ctx context.Context, input domain.CreateExpenseRecordInput) (*domain.Record, error) {
	userID, err := ctxdef.UserID(ctx)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	record, _, err := r.usecase.CreateExpenseRecord(ctx, userID, input.Title, input.Description, input.At, domain.AssetID(input.AssetID), input.Amount)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	return record, nil
}

// CreateTransferRecord is the resolver for the createTransferRecord field.
func (r *mutationResolver) CreateTransferRecord(ctx context.Context, input domain.CreateTransferRecordInput) (*domain.Record, error) {
	userID, err := ctxdef.UserID(ctx)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	record, _, _, err := r.usecase.CreateTransferRecord(ctx, userID, input.Title, input.Description, input.At, domain.AssetID(input.FromAssetID), domain.AssetID(input.ToAssetID), input.Amount)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	return record, nil
}

// Records is the resolver for the records field.
func (r *queryResolver) Records(ctx context.Context, assetID *string, sortKey domain.RecordSortKey, reverse bool, first *int, after *domain.PageCursor, last *int, before *domain.PageCursor) (*domain.RecordConnection, error) {
	pageParam, err := domain.NewPageParam(first, after, last, before, string(sortKey), reverse)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	userID, err := ctxdef.UserID(ctx)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	var assetIDPtr *domain.AssetID
	if assetID != nil {
		assetIDPtr = typeutil.Ptr(domain.AssetID(*assetID))
	}

	records, pageInfo, err := r.usecase.GetRecordsByUserIDAndAssetID(ctx, pageParam, userID, assetIDPtr)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	oldestRecord, err := records.OldestRecord(!pageParam.IsForward())
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	initTotalAssetAmount, err := r.usecase.CulcTotalAssetAmountAndCreateSnapshot(ctx, userID, assetIDPtr, *oldestRecord)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	return &domain.RecordConnection{
		Nodes:       records,
		PageInfo:    pageInfo,
		TotalAssets: initTotalAssetAmount,
	}, nil
}

// ID is the resolver for the id field.
func (r *recordResolver) ID(ctx context.Context, obj *domain.Record) (string, error) {
	return string(obj.ID), nil
}

// AssetChangeIncome is the resolver for the assetChangeIncome field.
func (r *recordResolver) AssetChangeIncome(ctx context.Context, obj *domain.Record) (*domain.AssetChange, error) {
	if obj.RecordType == domain.RecordTypeExpense {
		return nil, nil
	}

	thunk := r.AssetChangeLoader.Load(ctx, obj.ID)
	assetChangesAssociation, err := thunk()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if assetChangesAssociation.AssetChangeIncome == nil {
		return nil, domain.ErrAssetChangeNotFound
	}

	return assetChangesAssociation.AssetChangeIncome, nil
}

// AssetChangeExpense is the resolver for the assetChangeExpense field.
func (r *recordResolver) AssetChangeExpense(ctx context.Context, obj *domain.Record) (*domain.AssetChange, error) {
	if obj.RecordType == domain.RecordTypeIncome {
		return nil, nil
	}

	thunk := r.AssetChangeLoader.Load(ctx, obj.ID)

	assetChangesAssociation, err := thunk()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if assetChangesAssociation.AssetChangeExpense == nil {
		return nil, domain.ErrAssetChangeNotFound
	}

	return assetChangesAssociation.AssetChangeExpense, nil
}

// AssetChange returns graph.AssetChangeResolver implementation.
func (r *Resolver) AssetChange() graph.AssetChangeResolver { return &assetChangeResolver{r} }

// Record returns graph.RecordResolver implementation.
func (r *Resolver) Record() graph.RecordResolver { return &recordResolver{r} }

type assetChangeResolver struct{ *Resolver }
type recordResolver struct{ *Resolver }
